<!-- https://material.angular.io/components/tabs/overview -->



<!-- <mat-grid-list cols="3" rowHeight="200" [gutterSize]="'10px'">
  <mat-grid-tile colspan="2">Tile 1
    <mat-grid-tile-header>
      First In First Out (FIFO)
    </mat-grid-tile-header>
  </mat-grid-tile>
  <mat-grid-tile>Tile 2
    <mat-grid-tile-header>
      Título de Tile 2
    </mat-grid-tile-header>
    <img src="./assets/logo_uah_dark.png">
  </mat-grid-tile>
  <mat-grid-tile>
    <mat-grid-tile-header>
      Título de Tile 3
    </mat-grid-tile-header>
    Tile 3
  </mat-grid-tile>
  <mat-grid-tile colspan="2">
    <mat-grid-tile-header>
      Priority scheduling: Non Preemptive
    </mat-grid-tile-header>Tile 4
  </mat-grid-tile>
  <mat-grid-tile colspan="2">
    <mat-grid-tile-header>
      Título de Tile 5
    </mat-grid-tile-header>
    Priority scheduling: Preemptive</mat-grid-tile>
  <mat-grid-tile>
    <mat-grid-tile-header>
      Título de Tile 6
    </mat-grid-tile-header>Tile 6
  </mat-grid-tile>
  <mat-grid-tile>
    <mat-grid-tile-header>
      Título de Tile 7
    </mat-grid-tile-header>
    Tile 7</mat-grid-tile>
  <mat-grid-tile colspan="2">
    <mat-grid-tile-header>
      Round Robin
    </mat-grid-tile-header>Tile 8
  </mat-grid-tile>
</mat-grid-list> -->

<div class="todos">
  <br>
  <H1 style="text-align:center">Guía Básica de Planificadores</H1>
  <br>
  <mat-tab-group>
    <mat-tab label="Algoritmo de Planificación FIFO">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es FIFO
        </h3>
        <mat-divider></mat-divider>
        <br>El algoritmo de planificación FIFO (First-In, First-Out) se basa en el principio de que los procesos que
        llegan primero son los primeros en ser atendidos. En otras palabras, el primer proceso que llega a la cola de
        procesos es
        el primero en ser procesado por la CPU, y así sucesivamente hasta que todos los procesos en la cola hayan sido
        atendidos.<br>
      </div>

      <div class="texto2">
        <h3>
          <mat-icon> border_color</mat-icon> Ejemplo de FIFO
        </h3>
        <mat-divider></mat-divider><br>

        Supongamos que tenemos tres procesos en espera de ser ejecutados en la CPU, y llegan en el siguiente orden: <br>
        <ul>
          <li><strong>Proceso A</strong>, que requiere 10 unidades de tiempo de CPU.
          <li><strong>Proceso B</strong>, que requiere 5 unidades de tiempo de CPU.
          <li><strong>Proceso C</strong>, que requiere 7 unidades de tiempo de CPU.
        </ul>
        Cuando se utiliza el algoritmo de planificación FIFO, la CPU ejecutará los procesos en el orden en que
        llegaron a
        la cola de procesos. <br>Por lo tanto, el primer proceso que se ejecutará es el proceso A, que llegó primero a
        la
        cola.

        <br>La CPU asignará 10 unidades de tiempo de CPU al proceso A, luego se pasará al siguiente proceso, el
        proceso B.<br>
        La
        CPU asignará 5 unidades de tiempo de CPU al proceso B, y finalmente se ejecutará el proceso C, al que se le
        asignarán las 7 unidades de tiempo de CPU restantes.

        <br> Una vez que todos los procesos han sido ejecutados, el algoritmo de planificación FIFO termina su tarea.
      </div>
    </mat-tab>
    <mat-tab label="Algoritmo de Planificación Prioritaria: No Preventiva">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es Planificación Prioritaria No Preventiva
        </h3>
        <mat-divider></mat-divider><br>
        El algoritmo de planificación prioritaria no preventiva es un algoritmo de planificación de procesos en sistemas
        operativos donde cada proceso se asigna una prioridad y el proceso con la prioridad más alta se ejecuta primero.
        Si dos o más procesos tienen la misma prioridad, se pueden utilizar otros criterios, como el orden de llegada o
        el
        tiempo de ejecución previo, para determinar el orden de ejecución.<br>
        <br>
        A diferencia de los algoritmos de planificación preventiva, en los que el sistema operativo puede interrumpir un
        proceso en cualquier momento, el algoritmo de planificación prioritaria no preventiva permite que los procesos
        se
        ejecuten hasta que se completen o se bloqueen voluntariamente. Esto significa que un proceso con una prioridad
        baja puede bloquear el sistema si se ejecuta por un período de tiempo prolongado y no se bloquea por sí solo.
        <br>
        <br>Este algoritmo es útil en sistemas en los que se necesitan procesos de alta prioridad, como en sistemas de
        tiempo
        real, en los que la respuesta rápida es crucial, o en sistemas de control de procesos, donde se deben tomar
        decisiones rápidas en función de la entrada de sensores.<br>

        <br>Sin embargo, el algoritmo de planificación prioritaria no preventiva tiene la desventaja de que los procesos
        de
        baja prioridad pueden experimentar una inanición (starvation) y nunca ser ejecutados si hay muchos procesos de
        alta prioridad que están en la cola de procesos. Por lo tanto, es importante tener cuidado al asignar
        prioridades
        a los procesos y garantizar que los procesos de baja prioridad también tengan la oportunidad de ejecutarse.
      </div>
      <div class="texto2">
          <h3>
            <mat-icon> border_color</mat-icon> Ejemplo de Planificación Prioritaria No Preventiva
          </h3>
          <mat-divider></mat-divider><br>
        Supongamos que tenemos tres procesos, A, B y C, en una cola de procesos. El proceso A tiene una prioridad alta,
        el
        proceso B tiene una prioridad media y el proceso C tiene una prioridad baja. El tiempo de ejecución estimado
        para
        cada proceso es el siguiente:<br>

        <ul>
          <li><strong>Proceso A</strong>, que requiere 10 unidades de tiempo de CPU.
          <li><strong>Proceso B</strong>, que requiere 8 unidades de tiempo de CPU.
          <li><strong>Proceso C</strong>, que requiere 6 unidades de tiempo de CPU.
        </ul>

        El algoritmo de planificación prioritaria no preventiva ejecutará primero el proceso con la prioridad más alta.
        Por lo tanto, el proceso A se ejecutará primero, ya que tiene la prioridad más alta. Una vez que el proceso A se
        completa, el proceso B se ejecutará porque tiene la siguiente prioridad más alta. Finalmente, una vez que se
        completa el proceso B, el proceso C se ejecutará.<br>

        <br>El diagrama de Gantt para este ejemplo podría verse así:
        <br>
        | A | B | C |<br>
        0 10 18 24
        <br>
        <br>
        En resumen, el algoritmo de planificación prioritaria no preventiva ejecuta los procesos en función de su
        prioridad y permite que los procesos se ejecuten hasta que se completen o se bloqueen voluntariamente. Sin
        embargo, los procesos de baja prioridad pueden experimentar inanición si hay muchos procesos de alta prioridad
        en
        la cola de procesos.
      </div>
    </mat-tab>
    <mat-tab label="Algoritmo de Planificación Prioritaria: Preventiva">
        <div class="texto1">
          <h3>
            <mat-icon> library_books</mat-icon> Qué es Planificación Prioritaria Preventiva
          </h3>
          <mat-divider></mat-divider><br>
          El algoritmo de planificación prioritaria preventiva es un algoritmo de planificación de procesos en sistemas
          operativos donde cada proceso se asigna una prioridad y el proceso con la prioridad más alta se ejecuta
          primero.
          Si dos o más procesos tienen la misma prioridad, se pueden utilizar otros criterios, como el orden de llegada
          o el
          tiempo de ejecución previo, para determinar el orden de ejecución.<br>

          <br>A diferencia del algoritmo de planificación prioritaria no preventiva, en el que un proceso puede
          ejecutarse hasta
          que se complete o se bloquee voluntariamente, en el algoritmo de planificación prioritaria preventiva, el
          sistema
          operativo puede interrumpir un proceso en cualquier momento si un proceso de mayor prioridad llega a la cola
          de
          procesos. Esto significa que incluso si un proceso con una prioridad baja está en ejecución, el sistema
          operativo
          puede detenerlo y permitir que un proceso de mayor prioridad se ejecute.<br>

          <br>Este algoritmo es útil en sistemas en los que se necesitan procesos de alta prioridad y se debe garantizar
          una
          respuesta rápida y predecible. Por ejemplo, en sistemas de control de tráfico aéreo, donde la seguridad es una
          prioridad, se pueden utilizar algoritmos de planificación prioritaria preventiva para garantizar que los
          procesos
          críticos se ejecuten con prioridad y en tiempo real.<br>

          <br>Sin embargo, el algoritmo de planificación prioritaria preventiva también tiene desventajas. En
          particular, los
          procesos de baja prioridad pueden experimentar inanición si los procesos de alta prioridad continúan llegando
          a la
          cola de procesos. Para mitigar este problema, se pueden utilizar técnicas como la asignación de prioridades
          dinámicas, en las que las prioridades de los procesos se ajustan en función de su tiempo de ejecución previo o
          su
          tiempo de espera en la cola de procesos.<br>

          <br>En general, el algoritmo de planificación prioritaria preventiva es adecuado para sistemas en los que se
          necesita
          una respuesta rápida y predecible, pero se debe tener cuidado al asignar prioridades para evitar la inanición
          de
          procesos de baja prioridad.<br>
        </div>
        <div class="texto2">
          <h3>
            <mat-icon> border_color</mat-icon> Ejemplo de Planificación Prioritaria Preventiva
          </h3>
          <mat-divider></mat-divider><br>
        </div>
    </mat-tab>

    <mat-tab label="Algoritmo de Planificación Round-Robin">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es Round-Robin
        </h3>
        <mat-divider></mat-divider><br>

        El algoritmo de planificación Round Robin es un algoritmo de planificación de procesos en sistemas
        operativos
        que
        asigna un intervalo de tiempo de CPU a cada proceso en un orden circular y equitativo.<br>

        <br>El sistema operativo mantiene una cola de procesos listos para ser ejecutados y, en cada intervalo de tiempo
        de
        CPU, el proceso en la parte frontal de la cola recibe una asignación de tiempo de CPU fijo y limitado (también
        conocido como quantum) para su ejecución. Una vez que el quantum se ha agotado, el proceso se mueve al final de
        la
        cola, permitiendo que el siguiente proceso en la cola tenga su turno.<br>

        <br>Este algoritmo es útil en sistemas de tiempo compartido donde varios usuarios están trabajando en el mismo
        sistema
        al mismo tiempo. Debido a que cada proceso recibe un intervalo de tiempo justo y limitado, se evita que un
        proceso
        acapare la CPU, lo que garantiza un uso equitativo de los recursos del sistema.<br>

        <br>Además, el algoritmo Round Robin es fácil de implementar y puede evitar situaciones de inanición
        (starvation),
        donde un proceso nunca obtiene la oportunidad de ser ejecutado debido a que otros procesos siempre tienen
        prioridad. Sin embargo, también tiene algunas desventajas, como la sobrecarga adicional de cambiar de contexto y
        la posibilidad de que algunos procesos tengan que esperar demasiado tiempo para obtener una asignación de tiempo
        de CPU, lo que puede resultar en una disminución del rendimiento.<br>
      </div>
      <div class="texto2">
          <h3>
            <mat-icon> border_color</mat-icon> Ejemplo de Round-Robin
          </h3>
          <mat-divider></mat-divider><br>
        
        <br>Supongamos que tenemos cuatro procesos, A, B, C y D, en una cola de procesos, y el sistema operativo tiene
        un
        quantum de tiempo de CPU de 2 unidades de tiempo. El orden de llegada de los procesos a la cola es el
        siguiente:<br>

        Proceso A: llega en el tiempo 0
        Proceso B: llega en el tiempo 1
        Proceso C: llega en el tiempo 2
        Proceso D: llega en el tiempo 3

        <br>La cola de procesos se vería así:
        <br>
        <br>| A | B | C | D |
        <br>
        <br>El algoritmo Round Robin asignará una porción del tiempo de CPU a cada proceso en orden circular, en este
        caso,
        cada proceso recibirá 2 unidades de tiempo de CPU y se moverá al final de la cola después de que su tiempo haya
        transcurrido. El proceso que está al frente de la cola en un momento dado obtendrá el próximo turno de CPU.
        <br>
        <br>El diagrama de Gantt para el planificador Round Robin en este ejemplo sería el siguiente:

        <br> | A | B | C | D | A | B | C | D | A |
        <br> 0 2 3 5 6 8 9 11 12 14
        <br>
        <br>En el tiempo 0, el proceso A obtiene la primera asignación de tiempo de CPU y se ejecuta durante 2 unidades
        de
        tiempo, hasta el tiempo 2. Luego, el proceso B toma el control y se ejecuta durante 2 unidades de tiempo, hasta
        el
        tiempo 3, y así sucesivamente.

        <br>En resumen, el algoritmo Round Robin asegura que todos los procesos obtengan un tiempo de CPU justo y
        limitado, y
        evita que un proceso acapare la CPU. En este ejemplo, cada proceso obtiene 2 unidades de tiempo de CPU y se
        ejecuta en orden circular en la cola de procesos.
      </div>
    </mat-tab>
  </mat-tab-group>
</div>